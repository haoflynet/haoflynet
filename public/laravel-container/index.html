<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="豪翔天下" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="原文地址：https://www.insp.top/learn-laravel-container
转注：本文详细介绍了依赖注入以及Laravel IoC容器的原理，深入浅出，十分容易让人理解。
控制反转(IoC)：由外部负责其依赖需求的行为
依赖注入(DI)：只要不是由内部生产，而是由外部以参数或其他形式注入的，都属于依赖注入
容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容">
<meta property="og:type" content="article">
<meta property="og:title" content="[转]Laravel学习笔记——神奇的服务容器">
<meta property="og:url" content="https://haofly.net/laravel-container/index.html">
<meta property="og:site_name" content="豪翔天下">
<meta property="og:description" content="原文地址：https://www.insp.top/learn-laravel-container
转注：本文详细介绍了依赖注入以及Laravel IoC容器的原理，深入浅出，十分容易让人理解。
控制反转(IoC)：由外部负责其依赖需求的行为
依赖注入(DI)：只要不是由内部生产，而是由外部以参数或其他形式注入的，都属于依赖注入
容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容">
<meta property="og:updated_time" content="2016-02-22T05:23:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转]Laravel学习笔记——神奇的服务容器">
<meta name="twitter:description" content="原文地址：https://www.insp.top/learn-laravel-container
转注：本文详细介绍了依赖注入以及Laravel IoC容器的原理，深入浅出，十分容易让人理解。
控制反转(IoC)：由外部负责其依赖需求的行为
依赖注入(DI)：只要不是由内部生产，而是由外部以参数或其他形式注入的，都属于依赖注入
容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://haofly.net/laravel-container/"/>

  <title> [转]Laravel学习笔记——神奇的服务容器 | 豪翔天下 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-47480072-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">豪翔天下</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Change My World by Program</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-favorites">
          <a href="/favorites.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-flag"></i> <br />
            
            收藏
          </a>
        </li>
      
        
        <li class="menu-item menu-item-wiki">
          <a href="https://wiki.haofly.net" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-key"></i> <br />
            
            wiki
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                [转]Laravel学习笔记——神奇的服务容器
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-10T12:11:49+00:00" content="2015-07-10">
              2015-07-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/韦编三绝/" itemprop="url" rel="index">
                    <span itemprop="name">韦编三绝</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/laravel-container/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="laravel-container/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文地址：<a href="https://www.insp.top/learn-laravel-container" target="_blank" rel="external">https://www.insp.top/learn-laravel-container</a></p>
<p>转注：本文详细介绍了依赖注入以及Laravel IoC容器的原理，深入浅出，十分容易让人理解。</p>
<p><strong>控制反转(IoC)</strong>：由外部负责其依赖需求的行为</p>
<p><strong>依赖注入(DI)</strong>：只要不是由内部生产，而是由外部以参数或其他形式注入的，都属于依赖注入</p>
<p><em>容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容器。一个容器能够装什么，全部取决于你对该容器的定义。当然，有这样一种容器，它存放的不是<br>文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是 “解耦”<br>、“依赖注入（DI）”。本文就从这里开始。</em></p>
<h1 id="IoC-容器，-laravel-的核心"><a href="#IoC-容器，-laravel-的核心" class="headerlink" title="IoC 容器， laravel 的核心"></a>IoC 容器， laravel 的核心</h1><p>Laravel 的核心就是一个 IoC 容器，根据文档，称其为“服务容器”，顾名思义，该容器提供了整个框架中需要的一系列服务。作为初学者，很多人会在这一个概<br>念上犯难，因此，我打算从一些基础的内容开始讲解，通过理解面向对象开发中依赖的产生和解决方法，来逐渐揭开“依赖注入”的面纱，逐渐理解这一神奇的设计理念。</p>
<p>本文一大半内容都是通过举例来让读者去理解什么是 IoC（控制反转） 和 DI（依赖注入），通过理解这些概念，来更加深入。更多关于 laravel<br>服务容器的用法建议阅读文档即可。</p>
<h1 id="IoC-容器诞生的故事"><a href="#IoC-容器诞生的故事" class="headerlink" title="IoC 容器诞生的故事"></a>IoC 容器诞生的故事</h1><p>讲解 IoC 容器有很多的文章，我之前也写过。但现在我打算利用当下的灵感重新来过，那么开始吧。</p>
<h2 id="超人和超能力，依赖的产生！"><a href="#超人和超能力，依赖的产生！" class="headerlink" title="超人和超能力，依赖的产生！"></a>超人和超能力，依赖的产生！</h2><p>面向对象编程，有以下几样东西无时不刻的接触：接口、类还有对象。这其中，接口是类的原型，一个类必须要遵守其实现的接口；对象则是一个类实例化后的产物，我们称其为<br>一个实例。当然这样说肯定不利于理解，我们就实际的写点中看不中用的代码辅助学习。</p>
<p><em>怪物横行的世界，总归需要点超级人物来摆平。</em></p>
<p>我们把一个“超人”作为一个类，</p>
<pre><code>class Superman \{\}
</code></pre><p>我们可以想象，一个超人诞生的时候肯定拥有至少一个超能力，这个超能力也可以抽象为一个对象，为这个对象定义一个描述他的类吧。一个超能力肯定有多种属性、（操作）方<br>法，这个尽情的想象，但是目前我们先大致定义一个只有属性的“超能力”，至于能干啥，我们以后再丰富：</p>
<pre><code>class Power \{
    /*_
    * 能力值
    _/
    protected $ability;





/**
* 能力范围或距离
*/
protected $range;

public function __construct($ability, $range)
\{
    $this-&amp;gt;ability = $ability;
    $this-&amp;gt;range = $range;
\}
</code></pre><p>}</p>
<p>这时候我们回过头，修改一下之前的“超人”类，让一个“超人”创建的时候被赋予一个超能力：</p>
<pre><code>class Superman
\{
    protected $power;





public function __construct()
\{
    $this-&amp;gt;power = new Power(999, 100);
\}
</code></pre><p>}</p>
<p>这样的话，当我们创建一个“超人”实例的时候，同时也创建了一个“超能力”的实例，但是，我们看到了一点，“超人”和“超能力”之间不可避免的产生了一个依赖。</p>
<p><em>所谓“依赖”，就是“我若依赖你，少了你就没有我”。</em></p>
<p>在一个贯彻面向对象编程的项目中，这样的依赖随处可见。少量的依赖并不会有太过直观的影响，我们随着这个例子逐渐铺开，让大家慢慢意识到，当依赖达到一个量级时，是怎<br>样一番噩梦般的体验。当然，我也会自然而然的讲述如何解决问题。</p>
<h2 id="一堆乱麻-——-可怕的依赖"><a href="#一堆乱麻-——-可怕的依赖" class="headerlink" title="一堆乱麻 —— 可怕的依赖"></a>一堆乱麻 —— 可怕的依赖</h2><p>之前的例子中，超能力类实例化后是一个具体的超能力，但是我们知道，超人的超能力是多元化的，每种超能力的方法、属性都有不小的差异，没法通过一种类描述完全。我们现<br>在进行修改，我们假设超人可以有以下多种超能力：</p>
<ul>
<li>飞行，属性有：飞行速度、持续飞行时间</li>
<li>蛮力，属性有：力量值</li>
<li>能量弹，属性有：伤害值、射击距离、同时射击个数<br>我们创建了如下类：</li>
</ul>
<pre><code>class Flight
\{
    protected $speed;
    protected $holdtime;
    public function __construct($speed, $holdtime) \{\}
\}




class Force
\{
    protected $force;
    public function __construct($force) \{\}
\}




class Shot
\{
    protected $atk;
    protected $range;
    protected $limit;
    public function **construct($atk, $range, $limit) \{\}
\}
</code></pre><p><em>为了省事儿我没有详细写出 *</em>construct() 这个构造函数的全部，只写了需要传递的参数。</p>
<p>好了，这下我们的超人有点“忙”了。在超人初始化的时候，我们会根据需要来实例化其拥有的超能力吗，大致如下：</p>
<pre><code>class Superman
\{
    protected $power;





public function __construct()
\{
    $this-&amp;gt;power = new Fight(9, 100);
    // $this-&amp;gt;power = new Force(45);
    // $this-&amp;gt;power = new Shot(99, 50, 2);
    /*
    $this-&amp;gt;power = array(
        new Force(45),
        new Shot(99, 50, 2)
    );
    */
\}
</code></pre><p>}</p>
<p>我们需要自己手动的在构造函数内（或者其他方法里）实例化一系列需要的类，这样并不好。可以想象，假如需求变更（不同的怪物横行地球），需要更多的有针对性的 新的<br>超能力，或者需要 变更 超能力的方法，我们必须 重新改造<br>超人。换句话说就是，改变超能力的同时，我还得重新制造个超人。效率太低了！新超人还没创造完成世界早已被毁灭。</p>
<p><em>这时，灵机一动的人想到：为什么不可以这样呢？超人的能力可以被随时更换，只需要添加或者更新一个芯片或者其他装置啥的（想到钢铁侠没）。这样的话就不要整个重新来<br>过了。</em></p>
<p>对，就是这样的。</p>
<p>我们不应该手动在 “超人” 类中固化了他的 “超能力” 初始化的行为，而转由外部负责，由外部创造超能力模组、装置或者芯片等（我们后面统一称为<br>“模组”），植入超人体内的某一个接口，这个接口是一个既定的，只要这个 “模组”<br>满足这个接口的装置都可以被超人所利用，可以提升、增加超人的某一种能力。这种由外部负责其依赖需求的行为，我们可以称其为 “控制反转（IoC）”。</p>
<h2 id="工厂模式，依赖转移！"><a href="#工厂模式，依赖转移！" class="headerlink" title="工厂模式，依赖转移！"></a>工厂模式，依赖转移！</h2><p>当然，实现控制反转的方法有几种。在这之前，不如我们先了解一些好玩的东西。</p>
<p><em>我们可以想到，组件、工具（或者超人的模组），是一种可被生产的玩意儿，生产的地方当然是 “工厂（Factory）”，于是有人就提出了这样一种模式：<br>工厂模式。</em></p>
<p>工厂模式，顾名思义，就是一个类所以依赖的外部事物的实例，都可以被一个或多个 “工厂” 创建的这样一种开发模式，就是 “工厂模式”。</p>
<p>我们为了给超人制造超能力模组，我们创建了一个工厂，它可以制造各种各样的模组，且仅需要通过一个方法：</p>
<pre><code>class SuperModuleFactory
\{
    public function makeModule($moduleName, $options)
    \{
       switch ($moduleName) \{
           case &apos;Fight&apos;: return new Fight($options[0], $options[1]);
           case &apos;Force&apos;: return new Force($options[0]);
           case &apos;Shot&apos;: return new Shot($options[0], $options[1], $options[2]);
       \}
    \}
\}
</code></pre><p>这时候，超人 创建之初就可以使用这个工厂！</p>
<pre><code>class Superman
\{
    protected $power;





public function __construct()
\{
    // 初始化工厂
    $factory = new SuperModuleFactory;

    // 通过工厂提供的方法制造需要的模块
    $this-&amp;gt;power = $factory-&amp;gt;makeModule(&apos;Fight&apos;, [9, 100]);
    // $this-&amp;gt;power = $factory-&amp;gt;makeModule(&apos;Force&apos;, [45]);
    // $this-&amp;gt;power = $factory-&amp;gt;makeModule(&apos;Shot&apos;, [99, 50, 2]);
    /*
    $this-&amp;gt;power = array(
        $factory-&amp;gt;makeModule(&apos;Force&apos;, [45]),
        $factory-&amp;gt;makeModule(&apos;Shot&apos;, [99, 50, 2])
    );
    */
\}
</code></pre><p>}</p>
<p>可以看得出，我们不再需要在超人初始化之初，去初始化许多第三方类，只需初始化一个工厂类，即可满足需求。但这样似乎和以前区别不大，只是没有那么多 new<br>关键字。其实我们稍微改造一下这个类，你就明白，工厂类的真正意义和价值了。</p>
<pre><code>class Superman
\{
    protected $power;





public function __construct(array $modules)
\{
    // 初始化工厂
    $factory = new SuperModuleFactory;

    // 通过工厂提供的方法制造需要的模块
    foreach ($modules as $moduleName =&amp;gt; $moduleOptions) \{
        $this-&amp;gt;power[] = $factory-&amp;gt;makeModule($moduleName, $moduleOptions);
    \}
\}
</code></pre><p>}</p>
<p>// 创建超人 $superman = new Superman([ ‘Fight’ =&gt; [9, 100], ‘Shot’ =&gt; [99, 50, 2]<br>]);</p>
<p>现在修改的结果令人满意。现在，“超人” 的创建不再依赖任何一个 “超能力” 的类，我们如若修改了或者增加了新的超能力，只需要针对修改<br>SuperModuleFactory 即可。扩充超能力的同时不再需要重新编辑超人的类文件，使得我们变得很轻松。但是，这才刚刚开始。</p>
<h2 id="再进一步！IoC-容器的重要组成-——-依赖注入！"><a href="#再进一步！IoC-容器的重要组成-——-依赖注入！" class="headerlink" title="再进一步！IoC 容器的重要组成 —— 依赖注入！"></a>再进一步！IoC 容器的重要组成 —— 依赖注入！</h2><p>由 “超人” 对 “超能力” 的依赖变成 “超人” 对 “超能力模组工厂”<br>的依赖后，对付小怪兽们变得更加得心应手。但这也正如你所看到的，依赖并未解除，只是由原来对多个外部的依赖变成了对一个 “工厂”<br>的依赖。假如工厂出了点麻烦，问题变得就很棘手。</p>
<p><em>其实大多数情况下，工厂模式已经足够了。工厂模式的缺点就是：接口未知（即没有一个很好的契约模型，关于这个我马上会有解释）、产生对象类型单一。总之就是，还是不<br>够灵活。虽然如此，工厂模式依旧十分优秀，并且适用于绝大多数情况。不过我们为了讲解后面的 依赖注入 ，这里就先夸大一下工厂模式的缺陷咯。</em></p>
<p>我们知道，超人依赖的模组，我们要求有统一的接口，这样才能和超人身上的注入接口对接，最终起到提升超能力的效果。</p>
<p>事实上，我之前说谎了，不仅仅只有一堆小怪兽，还有更多的大怪兽。嘿嘿。额，这时候似乎工厂的生产能力显得有些不足 ——<br>由于工厂模式下，所有的模组都已经在工厂类中安排好了，如果有新的、高级的模组加入，我们必须修改工厂类（好比增加新的生产线）：</p>
<pre><code>class SuperModuleFactory
\{
    public function makeModule($moduleName, $options)
    \{
       switch ($moduleName) \{
            case &apos;Fight&apos;: return new Fight($options[0], $options[1]);
            case &apos;Force&apos;: return new Force($options[0]);
            case &apos;Shot&apos;: return new Shot($options[0], $options[1], $options[2]);
            // case &apos;more&apos;: .......
            // case &apos;and more&apos;: .......
            // case &apos;and more&apos;: .......
            // case &apos;oh no! its too many!&apos;: .......
        \}
    \}
\}
</code></pre><p>看到没。。。噩梦般的感受！</p>
<p><em>其实灵感就差一步！你可能会想到更为灵活的办法！对，下一步就是我们今天的主要配角 —— DI （依赖注入）</em></p>
<p>由于对超能力模组的需求不断增大，我们需要集合整个世界的高智商人才，一起解决问题，不应该仅仅只有几个工厂垄断负责。不过高智商人才们都非常自负，认为自己的想法是<br>对的，创造出的超能力模组没有统一的接口，自然而然无法被正常使用。这时我们需要提出一种契约，这样无论是谁创造出的模组，都符合这样的接口，自然就可被正常使用。</p>
<pre><code>interface SuperModuleInterface
\{
    /**
    * 超能力激活方法
    _
    * 任何一个超能力都得有该方法，并拥有一个参数
    _@param array $target 针对目标，可以是一个或多个，自己或他人
    */
    public function activate(array $target);
\}
</code></pre><p><em>上文中，我们定下了一个接口 （超能力模组的规范、契约），所有被创造的模组必须遵守该规范，才能被生产。</em></p>
<p><em>其实，这就是 php 中 接口（ interface ） 的用处和意义！很多人觉得，为什么 php 需要接口这种东西？难道不是 java 、 C#<br>之类的语言才有的吗？这么说，只要是一个正常的面向对象编程语言（虽然 php 可以面向过程），都应该具备这一特性。因为一个 对象（object）<br>本身是由他的模板或者原型 —— 类 （class） ，经过实例化后产生的一个具体事物，而有时候，实现统一种方法且不同功能（或特性）的时候，会存在很多的类（c<br>lass），这时候就需要有一个契约，让大家编写出可以被随时替换却不会产生影响的接口。这种由编程语言本身提出的硬性规范，会增加更多优秀的特性。</em></p>
<p><em>虽然有些绕，但通过我们接下来的实例，大家会慢慢领会接口带来的好处。</em></p>
<p>这时候，那些提出更好的超能力模组的高智商人才，遵循这个接口，创建了下述（模组）类：</p>
<pre><code>/**
_ X-超能量
_/
class XPower implements SuperModuleInterface
\{
    public function activate(array $target)
    \{
        // 这只是个例子。。具体自行脑补
    \}
\}




/__
_ 终极炸弹 （就这么俗）
_/
class UltraBomb implements SuperModuleInterface
\{
    public function activate(array $target)
    \{
        // 这只是个例子。。具体自行脑补
    \}
\}
</code></pre><p>同时，为了防止有些 “砖家” 自作聪明，或者一些叛徒恶意捣蛋，不遵守契约胡乱制造模组，影响超人，我们对超人初始化的方法进行改造：</p>
<pre><code>class Superman
\{
    protected $module;





public function __construct(SuperModuleInterface $module)
\{
    $this-&amp;gt;module = $module
\}
</code></pre><p>}</p>
<p>改造完毕！现在，当我们初始化 “超人” 类的时候，提供的模组实例必须是一个 SuperModuleInterface 接口的实现。否则就会提示错误。</p>
<p>正是由于超人的创造变得容易，一个超人也就不需要太多的超能力，我们可以创造多个超人，并分别注入需要的超能力模组即可。这样的话，虽然一个超人只有一个超能力，但超<br>人更容易变多，我们也不怕怪兽啦！</p>
<p><em>现在有人疑惑了，你要讲的 依赖注入 呢？</em></p>
<p><em>其实，上面讲的内容，正是依赖注入。</em></p>
<p>什么叫做 依赖注入？</p>
<p>本文从开头到现在提到的一系列依赖，只要不是由内部生产（比如初始化、构造函数 __construct 中通过工厂方法、自行手动 new<br>的），而是由外部以参数或其他形式注入的，都属于 依赖注入（DI） 。是不是豁然开朗？事实上，就是这么简单。下面就是一个典型的依赖注入：</p>
<pre><code>// 超能力模组
$superModule = new XPower;




// 初始化一个超人，并注入一个超能力模组依赖
$superMan = new Superman($superModule);
</code></pre><p>关于依赖注入这个本文的主要配角，也就这么多需要讲的。理解了依赖注入，我们就可以继续深入问题。慢慢走近今天的主角……</p>
<h2 id="更为先进的工厂-——-IoC-容器！"><a href="#更为先进的工厂-——-IoC-容器！" class="headerlink" title="更为先进的工厂 —— IoC 容器！"></a>更为先进的工厂 —— IoC 容器！</h2><p>刚刚列了一段代码：</p>
<pre><code>$superModule = new XPower;




$superMan = new Superman($superModule);
</code></pre><p>读者应该看出来了，手动的创建了一个超能力模组、手动的创建超人并注入了刚刚创建超能力模组。呵呵，手动。</p>
<p><em>现代社会，应该是高效率的生产，干净的车间，完美的自动化装配。</em></p>
<p>一群怪兽来了，如此低效率产出超人是不现实，我们需要自动化 —— 最多一条指令，千军万马来相见。我们需要一种高级的生产车间，我们只需要向生产车间提交一个脚本，<br>工厂便能够通过指令自动化生产。这种更为高级的工厂，就是工厂模式的升华 —— IoC 容器。</p>
<pre><code>class Container
\{
    protected $binds;





protected $instances;

public function bind($abstract, $concrete)
\{
    if ($concrete instanceof Closure) \{
        $this-&amp;gt;binds[$abstract] = $concrete;
    \} else \{
        $this-&amp;gt;instances[$abstract] = $concrete;
    \}
\}

public function make($abstract, $parameters = [])
\{
   if (isset($this-&amp;gt;instances[$abstract])) \{
        return $this-&amp;gt;instances[$abstract];
   \}

   array_unshift($parameters, $this);

   return call_user_func_array($this-&amp;gt;binds[$abstract], $parameters);
\}
</code></pre><p>}</p>
<p>这时候，一个十分粗糙的容器就诞生了。现在的确很简陋，但不妨碍我们进一步提升他。先着眼现在，看看这个容器如何使用吧！</p>
<pre><code>// 创建一个容器（后面称作超级工厂）
$container = new Container;




// 向该 超级工厂 添加 超人 的生产脚本
$container-&gt;bind(&apos;superman&apos;, function($container, $moduleName) \{
    return new Superman($container-&gt;make($moduleName));
\});




// 向该 超级工厂 添加 超能力模组 的生产脚本
$container-&gt;bind(&apos;xpower&apos;, function($container) \{
    return new XPower;
\});




// 同上
$container-&gt;bind(&apos;ultrabomb&apos;, function($container) \{
    return new UltraBomb;
\});




// **_*_****_*_****_* 华丽丽的分割线 _****_*_****_*_*******
// 开始启动生产
$superman_1 = $container-&gt;make(&apos;superman&apos;, &apos;xpower&apos;);
$superman_2 = $container-&gt;make(&apos;superman&apos;, &apos;ultrabomb&apos;);
$superman_3 = $container-&gt;make(&apos;superman&apos;, &apos;xpower&apos;);
// ...随意添加
</code></pre><p>看到没？通过最初的 绑定（bind） 操作，我们向 超级工厂 注册了一些生产脚本，这些生产脚本在生产指令下达之时便会执行。发现没有？我们彻底的解除了 超人<br>与 超能力模组 的依赖关系，更重要的是，容器类也丝毫没有和他们产生任何依赖！我们通过注册、绑定的方式向容器中添加一段可以被执行的回调（可以是匿名函数、非匿名<br>函数、类的方法）作为生产一个类的实例的 脚本 ，只有在真正的 生产（make） 操作被调用执行时，才会触发。</p>
<p>这样一种方式，使得我们更容易在创建一个实例的同时解决其依赖关系，并且更加灵活。当有新的需求，只需另外绑定一个“生产脚本”即可。</p>
<p><em>实际上，真正的 IoC 容器更为高级。我们现在的例子中，还是需要手动提供超人所需要的模组参数，但真正的 IoC<br>容器会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。Laravel<br>框架的服务容器正是这么做的。实现这种功能其实理论上并不麻烦，但我并不会在本文中写出，因为……我懒得写。</em></p>
<p><em>不过我告诉大家，这种自动搜寻依赖需求的功能，是通过 反射（Reflection） 实现的，恰好的，php 完美的支持反射机制！关于反射，php<br>官方文档有详细的资料，并且中文翻译基本覆盖，足够学习和研究！</em></p>
<p><em><a href="http://php.net/manual/zh/book.reflection.php" target="_blank" rel="external">http://php.net/manual/zh/book.reflection.php</a></em></p>
<p>现在，到目前为止，我们已经不再惧怕怪兽们了。高智商人才集思广益，井井有条，根据接口契约创造规范的超能力模组。超人开始批量产出。最终，人人都是超人，你也可以是<br>哦 ！</p>
<h1 id="回归正常世界。我们开始重新审视-laravel-的核心。"><a href="#回归正常世界。我们开始重新审视-laravel-的核心。" class="headerlink" title="回归正常世界。我们开始重新审视 laravel 的核心。"></a>回归正常世界。我们开始重新审视 laravel 的核心。</h1><p>现在，我们开始慢慢解读 laravel 的核心。其实，laravel 的核心就是一个 IoC 容器，也恰好是我之前所说的高级的 IoC 容器。</p>
<p>可以说，laravel 的核心本身十分轻量，并没有什么很神奇很实质性的应用功能。很多人用到的各种功能模块比如Route（路由）、Eloquent<br>ORM（数据库 ORM 组件）、Request and<br>Response（请求和响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被你所使用，其实都是 laravel<br>的服务容器负责的。</p>
<p>我们以大家最常见的 Route 类作为例子。大家可能经常见到路由定义是这样的：</p>
<pre><code>Route::get(&apos;/&apos;, function() \{
    // bla bla bla...
\});
</code></pre><p>实际上， Route 类被定义在这个命名空间：Illuminate\Routing\Router，文件vendor/laravel/framework/sr<br>c/Illuminate/Routing/Router.php。</p>
<p>我们通过打开发现，这个类的这一系列方法，如 get，post，any 等都不是静态（static）方法，这是怎么一回事儿？不要急，我们继续。</p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>我们在前文介绍 IoC 容器的部分中，提到了，一个类需要绑定、注册至容器中，才能被“制造”。</p>
<p>对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 laravel<br>称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是<br>服务提供者（ServiceProvider）。</p>
<p><em>虽然，绑定一个类到容器不一定非要通过 服务提供者（ServiceProvider） 。</em></p>
<p><em>但是，我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，laravel<br>将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的 服务提供者。</em><br><em>服务提供者主要分为两个部分，register（注册） 和 boot（引导、初始化），具体参考文档。register<br>负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至 boot 部分。</em></p>
<h2 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h2><p>我们现在解答之前关于 Route 的方法为何能以静态方法访问的问题。实际上这个问题文档上有写，简单说来就是模拟一个类，提供一个静态魔术方法__callSta<br>tic，并将该静态方法映射到真正的方法上。</p>
<p>我们使用的 Route 类实际上是 Illuminate\Support\Facades\Route 通过 class_alias() 函数创造的 别名<br>而已，这个类被定义在文件<br>vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php。</p>
<p>我们打开文件一看……诶？怎么只有这么简单的一段代码呢？</p>
<pre><code>&lt;?php namespace Illuminate\\Support\\Facades;




/__
_ @see \\Illuminate\\Routing\\Router
_/
class Route extends Facade \{





/**
* Get the registered name of the component.
*
* @return string
*/
protected static function getFacadeAccessor()
\{
    return &apos;router&apos;;
\}
</code></pre><p>}</p>
<p>其实仔细看，会发现这个类继承了一个叫做 Facade 的类，到这里谜底差不多要解开了。</p>
<p>上述简单的定义中，我们看到了 getFacadeAccessor 方法返回了一个 route，这是什么意思呢？事实上，这个值被一个<br>ServiceProvider 注册过，大家应该知道注册了个什么，当然是那个真正的路由类！</p>
<p><em>有人会问，Facade<br>是怎么实现的。我并不想说得太细，一个是我懒，另一个原因就是，自己发现一些东西更容易理解，并不容易忘记。很多细节我已经说了，建议大家自行去研究。</em></p>
<p>至此，我们已经讲的差不多了。</p>
<h1 id="和平！我们该总结总结了！"><a href="#和平！我们该总结总结了！" class="headerlink" title="和平！我们该总结总结了！"></a>和平！我们该总结总结了！</h1><p>无论如何，世界和平了。</p>
<p>这里要总结的内容就是，其实很多事情并不复杂，怕的是复杂的理论内容。我觉得很多东西一旦想通也就那么回事儿。很多人觉得 laravel<br>这不好那不好、这里难哪里难，我只能说，laravel 的确不是一流和优秀的框架，说 laravel 是一流、优秀的框架的人，不是 laravel<br>的粉丝那么就是跟风炒作。Laravel 最大的特点和优秀之处就是使用了很多 php 比较新（实际上并不新）的概念和技术（也就一堆语法糖）而已。因此<br>laravel 的确符合一个适宜学习的框架。Laravel 的构思的确和其他框架有很大不同，这也要求学习他的人必须熟练 php，并 基础扎实！如果你觉得学<br>laravel 框架十分困难，那么原因只有一个：你 php 基础不好。</p>
<p>另外，善于利用命名空间和面向对象的诸多特性，去追寻一些东西，你会发现，原来这一切这么容易。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/the-end-of-junior/" rel="next" title="大三，终结">
                <i class="fa fa-chevron-left"></i> 大三，终结
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/pdb-	debug-python/" rel="prev" title="使用PDB调试Python程序">
                使用PDB调试Python程序 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="haofly" />
          <p class="site-author-name" itemprop="name">haofly</p>
          <p class="site-description motion-element" itemprop="description">豪翔天下的个人博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">141</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/haoflynet" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/haoflynet" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              小伙伴们
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xiang.jwzcq.com" title="谢翔的博客" target="_blank">谢翔的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.phodal.com" title="Phodal" target="_blank">Phodal</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cnblogs.com/qingguo" title="qingguo" target="_blank">qingguo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://zkzhao.github.io/" title="zkzhao" target="_blank">zkzhao</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.qingguoing.com/" title="倾国倾城的博客" target="_blank">倾国倾城的博客</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#IoC-容器，-laravel-的核心"><span class="nav-number">1.</span> <span class="nav-text">IoC 容器， laravel 的核心</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IoC-容器诞生的故事"><span class="nav-number">2.</span> <span class="nav-text">IoC 容器诞生的故事</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#超人和超能力，依赖的产生！"><span class="nav-number">2.1.</span> <span class="nav-text">超人和超能力，依赖的产生！</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一堆乱麻-——-可怕的依赖"><span class="nav-number">2.2.</span> <span class="nav-text">一堆乱麻 —— 可怕的依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂模式，依赖转移！"><span class="nav-number">2.3.</span> <span class="nav-text">工厂模式，依赖转移！</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再进一步！IoC-容器的重要组成-——-依赖注入！"><span class="nav-number">2.4.</span> <span class="nav-text">再进一步！IoC 容器的重要组成 —— 依赖注入！</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更为先进的工厂-——-IoC-容器！"><span class="nav-number">2.5.</span> <span class="nav-text">更为先进的工厂 —— IoC 容器！</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回归正常世界。我们开始重新审视-laravel-的核心。"><span class="nav-number">3.</span> <span class="nav-text">回归正常世界。我们开始重新审视 laravel 的核心。</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#服务提供者"><span class="nav-number">3.1.</span> <span class="nav-text">服务提供者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Facade"><span class="nav-number">3.2.</span> <span class="nav-text">Facade</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#和平！我们该总结总结了！"><span class="nav-number">4.</span> <span class="nav-text">和平！我们该总结总结了！</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haofly</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'haoflynet';
      var disqus_identifier = 'laravel-container/';
      var disqus_title = "[转]Laravel学习笔记——神奇的服务容器";
      var disqus_url = 'https://haofly.net/laravel-container/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  

  

  

  

</body>
</html>
